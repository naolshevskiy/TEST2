# ReplicaSet
На практике очень редко приходится запускать один экземпляр приложения: как правило, приложение нужно масштабировать, то есть запускать несколько его экземпляров. В таких случаях использовать под не очень удобно, ведь для каждой реплики приложения придётся создавать YAML-манифест с описанием пода, а также управлять каждым подом отдельно.  

К счастью, для решения таких проблем в Kubernetes существует объект **ReplicaSet**. Он позволяет запускать заданное количество реплик нашего приложения, а также  поддерживать работу этих реплик, обеспечивая доступность приложения.  

Рассмотрим подробнее некоторые поля:
`spec.replicas` — количество экземпляров приложения;
`spec.template `— шаблон пода, который будет создаваться с помощью **ReplicaSet**;
`spec.selector` — селектор для выбора подов, которые будут управляться этим **ReplicaSet**. Механизм работы аналогичен селектору у Service. В манифесте **ReplicaSet** значение поля `spec.template.metadata.labels` должно соответствовать значению поля `spec.selector`.  

Удалим один из подов с помощью команды `kubectl delete pod <podname>`, получим список подов и увидим, что Kubernetes создал новый под. Потому что **ReplicaSet** поддерживает желаемое количество экземпляров приложения.  

К сожалению, **ReplicaSet** отвечает только за поддержание нужного числа подов. Если нам нужно развернуть stateless-приложение, обеспечив его отказоустойчивость и доступность, **ReplicaSet** — отличный вариант. Однако чаще всего также встаёт задача обновления этого приложения, причём обновления без потери доступности. В таком случае **ReplicaSet** уже не подойдёт.
Чтобы решать такие задачи, в Kubernetes существует абстракция **Deployment**.

# Deployment
**Deployment** не управляет подами, это всё ещё делает **ReplicaSet**, который, в свою очередь, создаётся с помощью объекта **Deployment**. 
Таким образом, мы получаем некую «эволюцию объектов» в Kubernetes: в более верхнеуровневой абстракции добавляется новая функциональность, а старая реализуется за счёт создания дочерних низкоуровневых объектов.

Создание в кластере объекта **Deployment** приведет к созданию **ReplicaSet** с желаемым количеством подов. Имя **ReplicaSet** формируется по тому же принципу, что и имена подов, управляемых объектом **ReplicaSet**.

При обновлении приложения создаётся новый **ReplicaSet**. Обратите внимание, что старый объект **ReplicaSet** не удаляется, он всё ещё остаётся в кластере.  

Почему так? Чтобы была возможность вернуться к предыдущей версии **Deployment**. Более того, откатиться можно не только к предыдущей версии, но и к любому **ReplicaSet**, который хранится в истории версий **Deployment**. Количество таких версий определяется параметром `spec.revisionHistoryLimit`, по умолчанию это значение равно 10, то есть по умолчанию в кластере будет храниться 10 объектов **ReplicaSet**. 